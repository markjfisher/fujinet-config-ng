# config makefile
#
# This is mostly target independent, just change TARGET and *FLAGS
# and Altirra emulator parts.

# I've only tested this on windows with MSYS2, but should work on linux.
# Haven't tested windows native.

TARGET := atari
PROGRAM := config
LIBS :=
CONFIG :=
CFLAGS = -Os -DBUILD_ATARI
ASFLAGS = --asm-include-dir src/common/inc --asm-include-dir src/$(TARGET)/inc
BUILD_DIR = build
LDFLAGS.atari = --mapfile $(BUILD_DIR)/config.map

LDFLAGS_LIB_PATH =
LDFLAGS_INC_PATH =

LDFLAGS = $(LDFLAGS.$(TARGET))

SRCDIR := src
OBJDIR := obj

TARGETOBJDIR := $(OBJDIR)/$(TARGET)

STATEFILE := Makefile.options

ifdef CC65_HOME
  CC = $(CC65_HOME)/bin/cl65
else
  CC := cl65
endif

ifeq '$(findstring ;,$(PATH))' ';'
    detected_OS := Windows
else
    detected_OS := $(shell uname 2>/dev/null || echo Unknown)
    detected_OS := $(patsubst CYGWIN%,Cygwin,$(detected_OS))
    detected_OS := $(patsubst MSYS%,MSYS,$(detected_OS))
    detected_OS := $(patsubst MINGW%,MSYS,$(detected_OS))
endif

XS := ""
ifeq ($(detected_OS),$(filter $(detected_OS),MSYS MINGW))
# need an eXtra Slash for altirra things
	XS := /
endif

ALTIRRA ?= $(ALTIRRA_HOME)/Altirra64.exe \
  $(XS)/portable $(XS)/portablealt:altirra-debug.ini \
  $(XS)/debug \
  $(XS)/debugcmd: ".loadsym build\config.lst" \
  $(XS)/debugcmd: "bp detect_banks"

#  $(XS)/debugcmd: "bp start"


atari_EMUCMD := $(ALTIRRA)

ifeq ($(EMUCMD),)
  EMUCMD = $($(CC65TARGET)_EMUCMD)
endif

ifeq ($(shell echo),)
  MKDIR = mkdir -p $1
  RMDIR = rmdir $1
  RMFILES = $(RM) $1
else
  MKDIR = mkdir $(subst /,\,$1)
  RMDIR = rmdir $(subst /,\,$1)
  RMFILES = $(if $1,del /f $(subst /,\,$1))
endif
COMMA := ,
SPACE := $(N/A) $(N/A)
define NEWLINE


endef
# Note: Do not remove any of the two empty lines above !

override PROGRAM := $(PROGRAM).com

rwildcard=$(wildcard $1$2)$(foreach d,$(wildcard $1*),$(call rwildcard,$d/,$2))

# root 'src' dir, mainly config.s
SOURCES := $(wildcard $(SRCDIR)/*.s)
SOURCES += $(wildcard $(SRCDIR)/*.c)
# add subdirs of $TARGET and "common"
SOURCES += $(call rwildcard,$(SRCDIR)/$(TARGET)/,*.s)
SOURCES += $(call rwildcard,$(SRCDIR)/$(TARGET)/,*.c)
SOURCES += $(call rwildcard,$(SRCDIR)/common/,*.s)
SOURCES += $(call rwildcard,$(SRCDIR)/common/,*.c)
# remove trailing and leading spaces.
SOURCES := $(strip $(SOURCES))

#OBJECTS := $(addsuffix .o,$(basename $(addprefix $(TARGETOBJDIR)/,$(notdir $(SOURCES)))))
#OBJECTS := $(pathsubst %.c,%.o,$(pathsubst %.s,%.o,$(SOURCES)))
OBJ1 := $(SOURCES:.c=.o)
OBJECTS := $(OBJ1:.s=.o)
OBJECTS := $(OBJECTS:$(SRCDIR)/%=$(OBJDIR)/%)


DEPENDS := $(OBJECTS:.o=.d)
LIBS += $(call rwildcard,$(SRCDIR)/$(TARGET)/,*.lib)
LIBS += $(call rwildcard,$(SRCDIR)/common/,*.lib)
CONFIG += $(call rwildcard,$(SRCDIR)/$(TARGET)/,*.cfg)
CONFIG += $(call rwildcard,$(SRCDIR)/common/,*.cfg)

# Select CONFIG file to use. Target specific configs have higher priority.
ifneq ($(word 2,$(CONFIG)),)
  CONFIG := $(firstword $(CONFIG))
  $(info Using config file $(CONFIG) for linking)
endif

.SUFFIXES:
.PHONY: all test clean zap

all: $(PROGRAM)

-include $(DEPENDS)
-include $(STATEFILE)

# If OPTIONS are given on the command line then save them to STATEFILE
# if (and only if) they have actually changed. But if OPTIONS are not
# given on the command line then load them from STATEFILE. Have object
# files depend on STATEFILE only if it actually exists.
ifeq ($(origin OPTIONS),command line)
  ifneq ($(OPTIONS),$(_OPTIONS_))
    ifeq ($(OPTIONS),)
      $(info Removing OPTIONS)
      $(shell $(RM) $(STATEFILE))
      $(eval $(STATEFILE):)
    else
      $(info Saving OPTIONS=$(OPTIONS))
      $(shell echo _OPTIONS_=$(OPTIONS) > $(STATEFILE))
    endif
    $(eval $(OBJECTS): $(STATEFILE))
  endif
else
  ifeq ($(origin _OPTIONS_),file)
    $(info Using saved OPTIONS=$(_OPTIONS_))
    OPTIONS = $(_OPTIONS_)
    $(eval $(OBJECTS): $(STATEFILE))
  endif
endif

# Transform the abstract OPTIONS to the actual cc65 options.
$(foreach o,$(subst $(COMMA),$(SPACE),$(OPTIONS)),$(eval $(_$o_)))

# Strip potential variant suffix from the actual cc65 target.
CC65TARGET := $(firstword $(subst .,$(SPACE),$(TARGET)))

$(OBJDIR):
	$(call MKDIR,$@)

$(BUILD_DIR):
	$(call MKDIR,$@)

SRC_INC_DIRS = $(sort $(dir $(wildcard $(SRCDIR)/$(TARGET)/*))) $(sort $(dir $(wildcard $(SRCDIR)/common/*)))

#$(info $$SOURCES = ${SOURCES})
#$(info $$OBJECTS = ${OBJECTS})
#$(info $$SRC_INC_DIRS = ${SRC_INC_DIRS})

vpath %.c $(SRC_INC_DIRS) $(SRCDIR)

# C compilation hasn't been tested yet.
$(OBJDIR)/%.o: %.c | $(OBJDIR)
	@$(call MKDIR,$(dir $@))
	$(CC) -t $(CC65TARGET) -c --create-dep $(@:.o=.d) $(CFLAGS) -o $@ $<

vpath %.s $(SRC_INC_DIRS) $(SRCDIR)

$(OBJDIR)/%.o: %.s | $(OBJDIR)
	@$(call MKDIR,$(dir $@))
	$(CC) -t $(CC65TARGET) -c --create-dep $(@:.o=.d) -l $(@:.o=.lst) --add-source $(ASFLAGS) -o $@ $<

$(PROGRAM): $(CONFIG) $(OBJECTS) $(LIBS) | $(BUILD_DIR)
	$(CC) -t $(CC65TARGET) $(LDFLAGS) -Ln $(BUILD_DIR)/$(@:.com=.lbl) -l $(BUILD_DIR)/$(@:.com=.lst) -o $(BUILD_DIR)/$@ $(patsubst %.cfg,-C %.cfg,$^)

test: $(PROGRAM)
	$(PREEMUCMD)
	$(EMUCMD) $(BUILD_DIR)\\$<
	$(POSTEMUCMD)

dist: $(PROGRAM)
	@echo "TODO! dist"

clean:
	$(call RMFILES,-r $(BUILD_DIR)/*)
	$(call RMFILES,-r $(OBJDIR)/*)
	$(call RMFILES,-r dist/*)

OBJDIRLIST := $(wildcard $(OBJDIR)/*)

zap:
	$(foreach o,$(OBJDIRLIST),-$(call RMFILES,$o/*.o $o/*.d $o/*.lst)$(NEWLINE))
	$(foreach o,$(OBJDIRLIST),-$(call RMDIR,$o)$(NEWLINE))
	-$(call RMDIR,$(OBJDIR))
	-$(call RMFILES,$(basename $(PROGRAM)).* $(STATEFILE))

-include *.mk
